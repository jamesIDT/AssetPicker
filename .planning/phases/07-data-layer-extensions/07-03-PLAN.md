---
phase: 07-data-layer-extensions
plan: 03
type: execute
---

<objective>
Build classification and divergence detection: sector classification with sector-level RSI, and multi-timeframe divergence scoring.

Purpose: Enable sector-relative analysis and identify price/RSI divergences that signal potential reversals.
Output: Extended `src/indicators.py` with sector and divergence functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Prior plan context:**
@.planning/phases/07-data-layer-extensions/07-02-SUMMARY.md

**Existing code:**
@src/rsi.py
@src/indicators.py

**Tech stack available:** Python 3.x (pure Python)
**Established patterns:** Indicators module with pure calculation functions
</context>

<tasks>

<task type="auto">
  <name>Task 1: Sector Classification</name>
  <files>src/sectors.py</files>
  <action>
Create new `src/sectors.py` module for sector classification.

Define sector mappings and implement sector RSI aggregation:

1. Create `SECTOR_MAPPINGS` dict mapping coin_id -> sector:
```python
SECTOR_MAPPINGS = {
    # Layer 1s
    "bitcoin": "L1",
    "ethereum": "L1",
    "solana": "L1",
    "cardano": "L1",
    "avalanche-2": "L1",
    "polkadot": "L1",
    "near": "L1",
    "cosmos": "L1",

    # DeFi
    "uniswap": "DeFi",
    "aave": "DeFi",
    "lido-dao": "DeFi",
    "maker": "DeFi",
    "compound-governance-token": "DeFi",

    # AI/Compute
    "render-token": "AI",
    "fetch-ai": "AI",
    "singularitynet": "AI",
    "akash-network": "AI",

    # Gaming/Metaverse
    "immutable-x": "Gaming",
    "the-sandbox": "Gaming",
    "axie-infinity": "Gaming",
    "gala": "Gaming",

    # Memes
    "dogecoin": "Meme",
    "shiba-inu": "Meme",
    "pepe": "Meme",
    "floki": "Meme",

    # Infrastructure
    "chainlink": "Infra",
    "the-graph": "Infra",
    "filecoin": "Infra",
    "arweave": "Infra",
}
```

2. Implement `get_sector(coin_id: str) -> str`:
   - Return sector from mapping or "Other" if not found

3. Implement `calculate_sector_rsi(coins: list[dict]) -> dict`:
   - Input: List of coin dicts with "id" and "daily_rsi" keys
   - Output: Dict mapping sector -> dict with:
     - `rsi`: Market-cap weighted average RSI of coins in sector
     - `coins`: List of coin IDs in sector
     - `count`: Number of coins in sector

Logic for weighted average:
- If market_cap available in coin dict, weight by it
- Otherwise, simple average
  </action>
  <verify>
Test in REPL:
```python
from src.sectors import get_sector, calculate_sector_rsi, SECTOR_MAPPINGS
assert get_sector("bitcoin") == "L1"
assert get_sector("uniswap") == "DeFi"
assert get_sector("unknown-coin") == "Other"

coins = [
    {"id": "bitcoin", "daily_rsi": 55, "market_cap": 1000},
    {"id": "ethereum", "daily_rsi": 50, "market_cap": 500},
]
sectors = calculate_sector_rsi(coins)
assert "L1" in sectors
assert 50 < sectors["L1"]["rsi"] < 55  # Weighted between 50 and 55
```
  </verify>
  <done>Sector mapping covers major coins, sector RSI aggregation works</done>
</task>

<task type="auto">
  <name>Task 2: Multi-Timeframe Divergence Detection</name>
  <files>src/indicators.py</files>
  <action>
Add divergence detection to `src/indicators.py`.

Implement `detect_divergence(price_history: list[float], rsi_history: list[float], lookback: int = 14) -> dict | None`:
- Input:
  - price_history: Recent prices (oldest to newest)
  - rsi_history: Corresponding RSI values
  - lookback: Period to check for divergence
- Output: Dict with keys:
  - `type`: "bullish" | "bearish" | "none"
  - `strength`: 1 | 2 (1 = weak, 2 = strong)
  - `description`: Human-readable description

Logic:
1. Find local price extremes in lookback period:
   - For bullish: Find two price lows where 2nd low < 1st low
   - For bearish: Find two price highs where 2nd high > 1st high

2. Check RSI at same points:
   - Bullish divergence: Price makes lower low, RSI makes higher low
   - Bearish divergence: Price makes higher high, RSI makes lower high

3. Strength:
   - 1: Divergence exists but RSI difference < 5 points
   - 2: Divergence with RSI difference >= 5 points

4. No divergence if neither pattern found

Also implement `calculate_divergence_score(daily_divergence: dict | None, weekly_divergence: dict | None) -> int`:
- Scoring per roadmap:
  - Score 1: Single timeframe divergence (strength 1)
  - Score 2: Single timeframe divergence (strength 2)
  - Score 4: Both timeframes show divergence
- Return 0 if no divergence on either timeframe
  </action>
  <verify>
Test in REPL:
```python
from src.indicators import detect_divergence, calculate_divergence_score

# Bullish divergence: price lower, RSI higher
prices = [100, 95, 98, 90, 92]  # Lower low at 90
rsis = [30, 25, 35, 28, 32]     # Higher low at 28 vs 25
result = detect_divergence(prices, rsis, 5)
assert result["type"] == "bullish"

# Score calculation
daily = {"type": "bullish", "strength": 1}
weekly = {"type": "bullish", "strength": 2}
assert calculate_divergence_score(daily, weekly) == 4  # Multi-TF confluence
```
  </verify>
  <done>Divergence detection identifies bull/bear divergences with scoring for multi-TF confluence</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from src.sectors import get_sector, calculate_sector_rsi"` succeeds
- [ ] `python -c "from src.indicators import detect_divergence, calculate_divergence_score"` succeeds
- [ ] Sector mappings cover coins likely in watchlist
- [ ] Divergence scoring follows roadmap spec (1/2/4)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- New src/sectors.py module with sector classification
- Divergence detection added to indicators.py
- Ready for plan 07-04 (signal lifecycle & decay score)
</success_criteria>

<output>
After completion, create `.planning/phases/07-data-layer-extensions/07-03-SUMMARY.md`
</output>
