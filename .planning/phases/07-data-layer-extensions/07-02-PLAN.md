---
phase: 07-data-layer-extensions
plan: 02
type: execute
---

<objective>
Build statistical analysis calculations: z-score thresholds, beta-adjusted relative strength, and mean reversion probability.

Purpose: Enable statistical extreme detection and relative performance measurement for opportunity scoring.
Output: Extended `src/indicators.py` with z-score, beta, and mean reversion functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Prior plan context:**
@.planning/phases/07-data-layer-extensions/07-01-SUMMARY.md

**Existing code:**
@src/rsi.py
@src/indicators.py

**Tech stack available:** Python 3.x (pure Python, no numpy/pandas)
**Established patterns:** Wilder's RSI, indicators module structure from 07-01
</context>

<tasks>

<task type="auto">
  <name>Task 1: Z-Score Thresholds</name>
  <files>src/indicators.py</files>
  <action>
Add z-score calculation to `src/indicators.py`.

Implement `calculate_zscore(values: list[float], lookback: int = 90) -> dict | None`:
- Input: List of values (e.g., RSI history), lookback period
- Output: Dict with keys:
  - `current`: Current value
  - `mean`: Rolling mean over lookback period
  - `std`: Rolling standard deviation
  - `zscore`: (current - mean) / std
  - `extreme`: "oversold" | "overbought" | "normal"

Logic:
- Use last `lookback` values to calculate mean and std
- zscore = (current - mean) / std
- Extreme classification:
  - zscore < -2.0: "oversold" (statistically extreme low)
  - zscore > 2.0: "overbought" (statistically extreme high)
  - else: "normal"

Handle edge cases:
- If std == 0: return zscore = 0 (no variation)
- If len(values) < lookback: use all available values
- If len(values) < 10: return None (insufficient data)
  </action>
  <verify>
Test in REPL:
```python
from src.indicators import calculate_zscore
# Normal distribution around 50
values = [50 + (i % 10 - 5) for i in range(100)]  # oscillates 45-55
values.append(30)  # Add extreme low
result = calculate_zscore(values)
assert result["extreme"] == "oversold"
assert result["zscore"] < -2.0
```
  </verify>
  <done>Function calculates z-score and correctly classifies statistical extremes</done>
</task>

<task type="auto">
  <name>Task 2: Beta-Adjusted Relative Strength</name>
  <files>src/indicators.py</files>
  <action>
Add beta calculation to `src/indicators.py`.

Implement `calculate_beta_adjusted_rsi(coin_returns: list[float], btc_returns: list[float], coin_rsi: float, btc_rsi: float) -> dict | None`:
- Input:
  - coin_returns: Daily % returns for coin (oldest to newest)
  - btc_returns: Daily % returns for BTC (same period)
  - coin_rsi: Current RSI of coin
  - btc_rsi: Current RSI of BTC
- Output: Dict with keys:
  - `beta`: Coin's beta to BTC (covariance / variance)
  - `expected_rsi`: What RSI we'd expect given BTC's RSI and beta
  - `residual`: coin_rsi - expected_rsi
  - `interpretation`: "outperforming" | "underperforming" | "expected"

Logic:
1. Calculate beta using covariance formula:
   - mean_coin = sum(coin_returns) / len
   - mean_btc = sum(btc_returns) / len
   - covariance = sum((c - mean_coin) * (b - mean_btc)) / len
   - variance_btc = sum((b - mean_btc)^2) / len
   - beta = covariance / variance_btc

2. Expected RSI (simplified linear model):
   - expected_rsi = 50 + beta * (btc_rsi - 50)
   - If BTC RSI is 60 and beta is 1.2, expected = 50 + 1.2*10 = 62

3. Residual = coin_rsi - expected_rsi
4. Interpretation:
   - residual > 5: "outperforming"
   - residual < -5: "underperforming"
   - else: "expected"

Require at least 30 return values. Return None if insufficient.
  </action>
  <verify>
Test in REPL:
```python
from src.indicators import calculate_beta_adjusted_rsi
# High beta coin (moves more than BTC)
coin_returns = [2, -3, 4, -2, 3] * 10  # 50 values
btc_returns = [1, -1.5, 2, -1, 1.5] * 10  # Half the magnitude
result = calculate_beta_adjusted_rsi(coin_returns, btc_returns, 70, 55)
assert result["beta"] > 1.5  # Coin is more volatile
assert "expected_rsi" in result
```
  </verify>
  <done>Function calculates beta and identifies over/underperformance relative to BTC</done>
</task>

<task type="auto">
  <name>Task 3: Mean Reversion Probability</name>
  <files>src/indicators.py</files>
  <action>
Add mean reversion probability to `src/indicators.py`.

Implement `calculate_mean_reversion_prob(rsi_history: list[float], current_rsi: float, lookback: int = 90) -> dict | None`:
- Input:
  - rsi_history: Historical RSI values
  - current_rsi: Current RSI to evaluate
  - lookback: How far back to analyze
- Output: Dict with keys:
  - `current_rsi`: Input RSI
  - `bucket`: RSI range bucket (e.g., "25-30")
  - `occurrences`: How many times RSI was in this bucket
  - `reversals`: How many of those led to reversal toward 50 within 5 periods
  - `probability`: reversals / occurrences (0-1)
  - `confidence`: "high" | "medium" | "low" based on sample size

Logic:
1. Bucket current RSI into 5-point ranges: 0-5, 5-10, ..., 95-100
2. Scan history for all times RSI was in same bucket
3. For each occurrence, check if RSI moved toward 50 within next 5 periods:
   - If oversold (< 50): reversal = any of next 5 values > current + 5
   - If overbought (> 50): reversal = any of next 5 values < current - 5
4. probability = reversals / occurrences
5. Confidence:
   - occurrences >= 10: "high"
   - occurrences >= 5: "medium"
   - occurrences < 5: "low"

Need at least 30 history values. Return None if insufficient.
  </action>
  <verify>
Test in REPL:
```python
from src.indicators import calculate_mean_reversion_prob
# History with clear mean reversion pattern
history = []
for i in range(100):
    if i % 10 == 0:
        history.append(25)  # Oversold
    else:
        history.append(50 + (i % 5))  # Normal range
result = calculate_mean_reversion_prob(history, 25)
assert result["probability"] > 0.5  # Most oversold periods reverted
```
  </verify>
  <done>Function calculates historical mean reversion probability with confidence level</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All 3 new functions importable from src/indicators.py
- [ ] Z-score handles edge cases (zero std, short history)
- [ ] Beta calculation handles equal-length return arrays
- [ ] Mean reversion handles all RSI ranges (0-100)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- 3 new statistical functions added to indicators.py
- Functions are pure calculations (no I/O)
- Ready for plan 07-03 (classification & divergence)
</success_criteria>

<output>
After completion, create `.planning/phases/07-data-layer-extensions/07-02-SUMMARY.md`
</output>
