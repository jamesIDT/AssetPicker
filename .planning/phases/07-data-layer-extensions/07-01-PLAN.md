---
phase: 07-data-layer-extensions
plan: 01
type: execute
---

<objective>
Build core market indicator calculations: regime detection, RSI acceleration, and volatility regime.

Purpose: Establish foundational market context signals that other calculations depend on (regime affects scoring, volatility affects interpretation).
Output: New `src/indicators.py` module with regime, acceleration, and volatility functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Prior phase context:**
@.planning/phases/06-polish/06-01-SUMMARY.md

**Existing code:**
@src/rsi.py
@src/coingecko.py

**Tech stack available:** Python 3.x, httpx, Plotly, Streamlit
**Established patterns:** Wilder's RSI calculation, tuple returns for partial failures

**Phase 7 scope:**
This is plan 1 of 4 for Phase 7: Data Layer Extensions.
Focus: Core indicator foundations (regime, acceleration, volatility).
</context>

<tasks>

<task type="auto">
  <name>Task 1: Regime Transition Detection</name>
  <files>src/indicators.py</files>
  <action>
Create new `src/indicators.py` module with regime detection function.

Implement `detect_regime(btc_weekly_rsi_history: list[float]) -> dict`:
- Input: List of BTC weekly RSI values (oldest to newest, at least 4 values)
- Output: Dict with keys:
  - `state`: "bull" | "bear" | "transition"
  - `momentum`: "rising" | "falling" | "neutral"
  - `combined`: "bull_rising" | "bull_falling" | "bear_rising" | "bear_falling" | "transition"

Logic:
- Bull: Current RSI > 50
- Bear: Current RSI <= 50
- Momentum: Compare current RSI to RSI from 3 periods ago
  - Rising: current > prev by > 3 points
  - Falling: current < prev by > 3 points
  - Neutral: within 3 points
- Transition: RSI crossed 50 within last 3 periods

Return None if insufficient data.
  </action>
  <verify>
Create simple test in Python REPL:
```python
from src.indicators import detect_regime
# Bull rising
detect_regime([45, 48, 55, 62]) == {"state": "bull", "momentum": "rising", "combined": "bull_rising"}
# Bear falling
detect_regime([55, 50, 45, 40]) == {"state": "bear", "momentum": "falling", "combined": "bear_falling"}
```
  </verify>
  <done>Function returns correct regime state for bull/bear/transition with momentum direction</done>
</task>

<task type="auto">
  <name>Task 2: RSI Acceleration</name>
  <files>src/indicators.py</files>
  <action>
Add RSI acceleration calculation to `src/indicators.py`.

Implement `calculate_rsi_acceleration(rsi_history: list[float]) -> dict | None`:
- Input: List of RSI values over time (oldest to newest, at least 3 values)
- Output: Dict with keys:
  - `velocity`: RSI change rate (current - previous)
  - `acceleration`: Change in velocity (current velocity - previous velocity)
  - `interpretation`: "accelerating_up" | "accelerating_down" | "decelerating_up" | "decelerating_down" | "stable"

Logic:
- velocity = rsi[-1] - rsi[-2]
- prev_velocity = rsi[-2] - rsi[-3]
- acceleration = velocity - prev_velocity
- Interpretation:
  - velocity > 0 and acceleration > 0: accelerating_up
  - velocity > 0 and acceleration < 0: decelerating_up
  - velocity < 0 and acceleration < 0: accelerating_down
  - velocity < 0 and acceleration > 0: decelerating_down
  - abs(velocity) < 1 and abs(acceleration) < 1: stable

Return None if insufficient data (< 3 values).
  </action>
  <verify>
Test in REPL:
```python
from src.indicators import calculate_rsi_acceleration
# Accelerating up (velocity positive and increasing)
calculate_rsi_acceleration([40, 42, 46]) # velocity=4, prev_vel=2, accel=2
# Should return {"velocity": 4, "acceleration": 2, "interpretation": "accelerating_up"}
```
  </verify>
  <done>Function calculates velocity, acceleration, and interpretation correctly</done>
</task>

<task type="auto">
  <name>Task 3: Volatility Regime Detection</name>
  <files>src/indicators.py</files>
  <action>
Add volatility regime detection to `src/indicators.py`.

Implement `detect_volatility_regime(price_history: list[float], period: int = 14) -> dict | None`:
- Input: List of prices (oldest to newest), ATR period
- Output: Dict with keys:
  - `current_atr`: Current ATR value (normalized as % of price)
  - `avg_atr`: Rolling average ATR over 4x period
  - `ratio`: current_atr / avg_atr
  - `regime`: "compressed" | "normal" | "expanded"

Logic:
1. Calculate True Range for each day: max(high-low, abs(high-prev_close), abs(low-prev_close))
   - Since we only have closes, use simplified TR = abs(close[i] - close[i-1])
2. ATR = SMA of TR over `period` days
3. Normalize: ATR / current_price * 100 (as percentage)
4. Calculate avg ATR over 4*period (56 days for period=14)
5. Ratio = current_normalized_atr / avg_normalized_atr
6. Regime:
   - ratio < 0.7: "compressed"
   - ratio > 1.3: "expanded"
   - else: "normal"

Need at least 4*period + 1 prices. Return None if insufficient.
  </action>
  <verify>
Test in REPL with synthetic data:
```python
from src.indicators import detect_volatility_regime
# Stable prices (compressed volatility)
stable = [100 + i*0.1 for i in range(60)]  # Slow drift
result = detect_volatility_regime(stable)
assert result["regime"] == "compressed"
```
  </verify>
  <done>Function correctly identifies compressed/normal/expanded volatility regimes</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from src.indicators import detect_regime, calculate_rsi_acceleration, detect_volatility_regime"` succeeds
- [ ] All three functions handle edge cases (insufficient data returns None)
- [ ] No new dependencies added (pure Python calculations)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- New src/indicators.py module with 3 functions
- Functions are pure calculations (no I/O, no side effects)
- Ready for plan 07-02 (statistical analysis functions)
</success_criteria>

<output>
After completion, create `.planning/phases/07-data-layer-extensions/07-01-SUMMARY.md`
</output>
