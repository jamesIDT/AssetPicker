---
phase: 23-segmented-ring-viz
plan: 01
type: execute
---

<objective>
Implement segmented ring visualization around scatter markers showing divergence status across 6 timeframes (1w, 3d, 1d, 12h, 4h, 1h).

Purpose: Enable visual identification of multi-timeframe divergence alignment at a glance
Output: Updated RSI scatter chart with 6-segment rings around each marker (colored by divergence type)
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/2025-01-25-multi-timeframe-divergence-display.md

# Prior phase context:
@.planning/phases/22-multi-timeframe-candles/22-01-SUMMARY.md

# Key files:
@src/charts.py

**Tech stack available:** Plotly go.Figure, shapes, SVG paths
**Established patterns:** fig.add_shape() for rectangles/lines, multi-trace layering
**Constraining decisions:**
- Phase 22: Multi-TF divergence available in st.session_state.multi_tf_divergence[coin_id]
- Segment order (clockwise from top): 1w, 3d, 1d, 12h, 4h, 1h
- Colors: Green (#22c55e) = bullish, Red (#ef4444) = bearish, Gray (#6b7280) = none
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create arc segment rendering utility</name>
  <files>src/charts.py</files>
  <action>
Add function `create_arc_segment_path(cx, cy, radius, start_angle, end_angle, width)` that returns SVG path string for an arc segment.

Implementation:
- Use SVG arc path syntax: `M x1 y1 A rx ry 0 large-arc sweep x2 y2`
- For a ring segment, need inner arc + outer arc + connecting lines
- Angles in degrees, clockwise from 12 o'clock (top = 0 degrees)
- Return path string suitable for `fig.add_shape(type="path", path=...)`

Helper function `get_segment_angles(segment_index)` to return start/end angles for each of 6 segments:
- Segment 0 (1w): -30 to 30 degrees (top center)
- Segment 1 (3d): 30 to 90 degrees
- Segment 2 (1d): 90 to 150 degrees
- Segment 3 (12h): 150 to 210 degrees
- Segment 4 (4h): 210 to 270 degrees
- Segment 5 (1h): 270 to 330 degrees

Note: Plotly uses standard cartesian coordinates (0 degrees = right, counterclockwise positive), so convert from "clockwise from top" convention.
  </action>
  <verify>Add a simple test in charts.py docstring or inline comment showing expected path output for a known input</verify>
  <done>Arc segment path function returns valid SVG path strings for all 6 segment positions</done>
</task>

<task type="auto">
  <name>Task 2: Add segmented rings to build_rsi_scatter</name>
  <files>src/charts.py, app.py</files>
  <action>
Modify `build_rsi_scatter` to accept `multi_tf_divergence` parameter:
- Type: `dict[str, dict[str, dict]]` where keys are coin symbols, values are dicts of timeframe -> divergence info
- Each divergence info has `type` ("bullish"/"bearish"/"none") and `score`

For each coin marker:
1. Look up multi_tf_divergence for that coin
2. For each of 6 timeframes (1w, 3d, 1d, 12h, 4h, 1h):
   - Get divergence type for that timeframe
   - Determine color: bullish=#22c55e, bearish=#ef4444, none=#6b7280
   - Call create_arc_segment_path with marker position (x, y in data coords)
   - Add shape with fig.add_shape(type="path", path=path, fillcolor=color, line_width=0)

Important considerations:
- Shapes use data coordinates by default (xref="x", yref="y")
- Ring radius should be visually appropriate (~0.5-1.0 RSI units on x-axis)
- Account for log scale y-axis when converting positions
- Add shapes BEFORE marker traces so markers render on top

Performance: With 48 coins x 6 segments = 288 shapes. This should be acceptable for Plotly.

In app.py:
- Pass multi_tf_divergence from session_state to build_rsi_scatter
  </action>
  <verify>Run `streamlit run app.py`, verify rings appear around markers on the scatter plot</verify>
  <done>Segmented rings render around each marker with correct colors per timeframe divergence</done>
</task>

<task type="auto">
  <name>Task 3: Handle edge cases and optimize rendering</name>
  <files>src/charts.py</files>
  <action>
Handle edge cases:
1. Missing multi_tf_divergence data: Default all segments to gray (no divergence)
2. Partial timeframe data: If some timeframes missing for a coin, render those segments as gray
3. Y-axis log scale: Ensure ring segments scale correctly on log scale
   - May need to convert radius to log units or use paper/domain coordinates
   - Test with coins at different y positions to verify consistent ring size

Optimize if needed:
- If rendering is slow, consider using paper coordinates for rings (relative positioning)
- Group shapes by color to reduce draw calls if Plotly supports batching

Update corner legend annotation to include ring explanation:
- Current: "circle No div  + Bull  diamond Bear  circle Score 2+  circle circle Score 4"
- New: Add "Ring: 6 TFs (clockwise from 1w)" or similar brief explanation
  </action>
  <verify>Test with multiple coins at varying y positions, confirm consistent ring appearance</verify>
  <done>Rings render consistently regardless of coin position, edge cases handled gracefully</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `streamlit run app.py` launches without errors
- [ ] Segmented rings visible around scatter markers
- [ ] Ring colors match divergence data (green=bullish, red=bearish, gray=none)
- [ ] Rings render consistently at different chart positions
- [ ] Performance acceptable (<2 seconds render with 48 coins)
</verification>

<success_criteria>

- All tasks completed
- Segmented rings render around each scatter marker
- 6 segments visible (1w at top, clockwise)
- Colors correctly reflect multi-TF divergence data
- Chart remains interactive (hover, zoom work)
- No performance regression
</success_criteria>

<output>
After completion, create `.planning/phases/23-segmented-ring-viz/23-01-SUMMARY.md`
</output>
