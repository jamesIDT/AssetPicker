---
phase: 22-multi-timeframe-candles
plan: 01
type: execute
---

<objective>
Aggregate 4h, 12h, 3d candles from raw OHLC data and calculate RSI + divergence for all 6 timeframes.

Purpose: Enable multi-timeframe divergence analysis by providing RSI and divergence signals across 1h, 4h, 12h, 1d, 3d, 1w.
Output: Multi-timeframe data structure available in session state for use by scatter rings and divergence matrix.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/2025-01-25-multi-timeframe-divergence-display.md

# Phase 21 provides:
@.planning/phases/21-hourly-data-integration/21-01-SUMMARY.md

**Key files:**
@src/rsi.py
@src/indicators.py
@app.py

**Tech stack available:**
- CoinGecko hourly data in `st.session_state.hourly_history` (from Phase 21)
- CoinGecko daily data in `st.session_state.coin_histories`
- `calculate_rsi()` works on any list of closes
- `get_weekly_rsi()` pattern for aggregating daily → weekly
- `detect_divergence()` takes price_history + rsi_history

**Data flow from spec:**
```
Hourly (90 days) ─┬─ 1h candles ─── RSI ── Divergence
                  ├─ 4h aggregated ── RSI ── Divergence
                  └─ 12h aggregated ─ RSI ── Divergence

Daily (120 days) ─┬─ 1d candles ─── RSI ── Divergence (existing)
                  ├─ 3d aggregated ── RSI ── Divergence
                  └─ 1w aggregated ─ RSI ── Divergence (existing)
```

**Lookback periods for RSI (14-period):**
- 1h: 14 hours of data
- 4h: 56 hours (~2.3 days)
- 12h: 168 hours (7 days)
- 1d: 14 days (existing)
- 3d: 42 days
- 1w: 14 weeks (~3.5 months, existing)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add candle aggregation functions</name>
  <files>src/rsi.py</files>
  <action>
Add three aggregation functions to rsi.py:

1. `aggregate_to_4h_closes(hourly_prices: list) -> list[float]`
   - Group hourly [[timestamp_ms, price], ...] into 4-hour buckets
   - Return last price of each bucket (the "close")
   - Bucket by floor(timestamp / 4 hours)

2. `aggregate_to_12h_closes(hourly_prices: list) -> list[float]`
   - Same pattern, 12-hour buckets

3. `aggregate_to_3d_closes(daily_prices: list) -> list[float]`
   - Group daily data into 3-day buckets
   - Return last price of each bucket

Pattern reference: `get_weekly_rsi()` shows ISO week grouping - use similar timestamp bucketing approach but with fixed hour/day intervals instead of calendar weeks.

Do NOT use datetime parsing - just divide timestamp_ms by bucket_size_ms for consistent bucketing.
  </action>
  <verify>
Import and test:
```python
from src.rsi import aggregate_to_4h_closes, aggregate_to_12h_closes, aggregate_to_3d_closes
# Verify functions exist and return lists
```
  </verify>
  <done>Three aggregation functions added that bucket OHLC data by time interval</done>
</task>

<task type="auto">
  <name>Task 2: Add multi-timeframe RSI calculator</name>
  <files>src/rsi.py</files>
  <action>
Add `calculate_multi_tf_rsi(hourly_data: dict, daily_data: dict) -> dict` that returns RSI for all 6 timeframes.

Input format (CoinGecko response):
- hourly_data: {"prices": [[ts_ms, price], ...]}
- daily_data: {"prices": [[ts_ms, price], ...]}

Output format:
```python
{
    "1h": 45.2,   # RSI from hourly closes
    "4h": 48.1,   # RSI from 4h aggregated
    "12h": 52.3,  # RSI from 12h aggregated
    "1d": 55.0,   # RSI from daily closes
    "3d": 58.2,   # RSI from 3d aggregated
    "1w": 62.1,   # RSI from weekly aggregated (existing pattern)
}
```

Implementation:
1. Extract closes from hourly_data for 1h RSI
2. Aggregate hourly to 4h, calculate RSI
3. Aggregate hourly to 12h, calculate RSI
4. Extract closes from daily_data for 1d RSI
5. Aggregate daily to 3d, calculate RSI
6. Use existing get_weekly_rsi() for 1w

Return None for any timeframe with insufficient data. Do NOT fail if some timeframes unavailable - return dict with available values only.
  </action>
  <verify>
Test with sample data structure to verify dict output shape.
  </verify>
  <done>Multi-TF RSI function returns dict with 6 timeframe RSI values</done>
</task>

<task type="auto">
  <name>Task 3: Add multi-TF divergence and integrate into app</name>
  <files>src/indicators.py, app.py</files>
  <action>
**In src/indicators.py:**

Add `calculate_multi_tf_divergence(hourly_data: dict, daily_data: dict, multi_tf_rsi: dict) -> dict`:
- For each timeframe, build price_history and rsi_history arrays
- Call existing `detect_divergence()` for each
- Return dict keyed by timeframe:
```python
{
    "1h": {"type": "bullish", "strength": 1, ...},
    "4h": {"type": "none", ...},
    ...
}
```

Use lookback=14 for hourly TFs (1h/4h/12h), lookback=14 for daily TFs (1d/3d/1w).

Building RSI history: Need to calculate RSI at each point in history. For efficiency, store the last 14 RSI values per timeframe.

**In app.py:**

In `fetch_all_data()` after hourly fetch completes, add multi-TF calculation:
```python
# After existing fetch completes
for coin_id in coin_ids:
    hourly = st.session_state.hourly_history.get(coin_id, {})
    daily = st.session_state.coin_histories.get(coin_id, {})

    # Calculate multi-TF RSI
    multi_rsi = calculate_multi_tf_rsi(hourly, daily)

    # Calculate multi-TF divergence
    multi_div = calculate_multi_tf_divergence(hourly, daily, multi_rsi)

    # Store in session state
    st.session_state.multi_tf_rsi[coin_id] = multi_rsi
    st.session_state.multi_tf_divergence[coin_id] = multi_div
```

Initialize session state dicts at top of app.py if not exists.
  </action>
  <verify>
Run app with `streamlit run app.py`, verify no errors on refresh, check session state contains multi_tf_rsi and multi_tf_divergence dicts.
  </verify>
  <done>Multi-TF divergence calculated for all coins, session state populated with 6-timeframe RSI and divergence data</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `python -c "from src.rsi import aggregate_to_4h_closes, aggregate_to_12h_closes, aggregate_to_3d_closes, calculate_multi_tf_rsi"` succeeds
- [ ] `python -c "from src.indicators import calculate_multi_tf_divergence"` succeeds
- [ ] App runs without errors
- [ ] Session state contains multi_tf_rsi and multi_tf_divergence after refresh
</verification>

<success_criteria>

- Candle aggregation functions work for 4h, 12h, 3d intervals
- Multi-TF RSI returns dict with up to 6 timeframes
- Multi-TF divergence returns divergence signals per timeframe
- Session state populated for use by Phase 23 (segmented ring viz) and Phase 25 (divergence matrix)
</success_criteria>

<output>
After completion, create `.planning/phases/22-multi-timeframe-candles/22-01-SUMMARY.md`
</output>
